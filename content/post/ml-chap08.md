---
title: "chap 08 - 集成学习 | Ensemble learning"
date: 2017-12-11
lastmod: 2018-04-17
draft: false
show_comments: true
keywords: []
description: ""
tags: [Notes]
categories: [Machine Learning]
---

![集成学习](https://i.loli.net/2019/03/23/5c95eede645ea.png)

## 8.1 个体与集成

**def【集成学习】：**

通过构建并结合多个学习器来完成学习任务，有时也被称作“多分类器系统”(multi-classifier system)、“基于委员会的学习”(committee-based learning)等。

**集成学习的一般结构：**

先生成一组“个体学习器”，然后用某种方法把它们结合起来，最后输出结果。

![3F39DD12-B8ED-48DB-8B8F-2263746F83A0](https://i.loli.net/2019/03/23/5c95eee90aba4.png)


**个体学习器：**

通常采用现有的方法，如，C4.5决策树算法、BP神经网络算法。

**个体学习器的分类：**

* **同质 homogenous**：个体学习器采用的方法相同。如，“神经网络集成”中全是神经网络、“决策树集成”中全是决策树。此时，个体学习器对应的算法称为**“基学习算法”(base learning algorithm)**。
* **异质 heterogenous**：个体学习器采用的方法不同。如，同时包含决策树和神经网络。此时，个体学习器称为**“组件学习器”(component learner)**或直接称为个体学习器。

**集成学习的性能：**

1. 集成学习通过结合多个学习器，其泛化性能常优于单个学习器。
    * 弱学习器【常指泛化性能略优于随机猜测的学习器。如，在二分类问题上精度略高于50%的学习器。】的集成效应尤其明显，很多集成学习的理论研究都是针对弱学习器进行的。基学习器有时也被称作弱学习器。
    * 理论上，弱学习器集成可获得较好的泛化性能。但是实际中，为了使用较少的个体学习器、或重用关于常见学习器的经验，人们通常选用较强的学习器、
2. 如何获得比单一学习器更优的泛化性能？
    * **方法**：选用“投票法” voting （少数服从多数）产生。
    * **要求**：个体学习器有一定的“准确性”（学习器不能太坏），且“多样性”diversity（学习器要有差异）。

举一个例子🌰：

在二分类任务中，假定三个分类器在三个测试样本上的表现如图8.2所示，其中√表示分类正确，×表示分类错误。集成学习的结果采用“投票法”产生。

* 在图8.2(a)中，每个分类器都只有66.6%的精度，但集成学习的精度达到100%；
* 在图8.2(b)中，三个分类器无差别，集成后性能没有提高；
* 在图8.2(c)中，每个分类器的精度为33.3%，集成学习的结果更糟。

![E474526B-4DCE-43CB-9AE9-55F5495687AD](https://i.loli.net/2019/03/23/5c95eeefabdf3.png)

**分析：**

考虑二分类问题$y \in \{-1, +1\}$和真实函数$f$，假定基分类器的错误率为$\epsilon$，即对每个基分类器，有

![126530E7-C0CC-439C-8885-7379E386AFBF](https://i.loli.net/2019/03/23/5c95eed2e922e.png)

假设集成通过简单投票法结合$T$个基分类器，若有超过半数的基分类器正确，则集成分类就正确：

![BE7841BB-F499-47AF-A6AA-564A257A0B11](https://i.loli.net/2019/03/23/5c95eed31a84f.png)

**假设基分类器的错误率相互独立**，则由Hoeffding不等式可知，集成的错误率为

![7F1A613E-BEF2-4E3C-8C0F-61B0605F97E2](https://i.loli.net/2019/03/23/5c95eed850a92.png)

上式表明，**随着集成中个体分类器数目T的增大，集成的错误率将指数级下降，最终趋向于零**。

**基学习器的误差独立性：**

    1. 基学习器是为了解决同一个问题训练出来的，显然不互相独立；
    2. 个体学习器的“准确性”和“多样性”本身存在冲突（一般，准确性高时，增加多样性就会牺牲准确性）；
    3. 如何产生并结合“好而不同”的个体学习器，是集成学习研究的核心。

**集成学习方法分类：**

1. 序列化方法：
    * 个体学习器间存在强依赖关系、必须串行生成。
    * 代表方法：Boosting。
2. 并行化方法：
    * 个体学习器间不存在强依赖关系、可同时生成。
    * 代表方法：Bagging，随机森林 Random Forest。


## 8.2 Boosting

Boosting是一族可将弱学习器提升为强学习器的算法。

**基本步骤：**

1. 从初始训练集训练出$1$个基学习器；
2. 根据基学习器的表现对样本分布进行调整，使先前基学习器做错的训练样本在后续受到更多关注；
3. 基于调整后的样本分布训练下一个基学习器；
4. 重复上述步骤，直至基学习器**数目**达到事先指定值$T$；
5. 将得到的$T$个基学习器进行加权结合。

**Adaboost [Freund and Schapire,1997]：Boosting族算法的最著名代表**

* 算法描述：其中$y \in \{-1, +1\}$，真实函数为$f$。

![05EF5330-FF1B-482B-B869-A26350DB0BF1](https://i.loli.net/2019/03/23/5c95eeefc1912.png)
说明：
1：初始化样本权值分布；
2、3：基于分布$D_t$从数据集$D$中训练处分类器$h_t$；
4：估计$h_t$的误差；
6：确定分类器$h_t$的权值$\alpha_t$；
7：更新样本分布，其中$Z_t$是规范化因子，以确保$D_{t+1}$是一个分布。

**推导过程：**

* 基于“加性模型”(additive model)迭代式优化（最小化）指数损失函数(exponential loss function)[Friedman et al., 2000]

即，用基学习器的线性组合

![9AD8ECF9-7C81-4F4A-A96B-5A655B07F13A](https://i.loli.net/2019/03/23/5c95eed2ef548.png)

来最小化指数损失函数

![9422E28E-507D-4277-A7CB-AC58B1BD2FBE](https://i.loli.net/2019/03/23/5c95eed2ed950.png)


**1️⃣求让指数损失函数最小的基学习器的线性组合H(x)**

若$H(x)$能令指数损失函数最小化，则考虑式(8.5)对$H(x)$的偏导

![BBDF1AE2-C09B-4423-BBB2-1483EA4F77E5](https://i.loli.net/2019/03/23/5c95eee1af57f.png)

令式(8.6)为零可解得

![F9A60C5B-D500-44CB-AAA4-79CC6BD3704](https://i.loli.net/2019/03/23/5c95eed31fa90.png)

因此，有

![4AA0A90F-10CB-40C2-BA4A-CCF492FD151](https://i.loli.net/2019/03/23/5c95eee9161e1.png)

> 这里忽略了$P(f(x)=1|x)=P(f(x)=-1|x)$的情形。

这意味着$sign(H(x))$达到了贝叶斯最优错误率。
换言之，若指数损失函数最小化，则分类错误率也将最小化；说明指数损失函数是分类任务原本0/1损失函数的一致(consistent)的替代损失函数。指数损失函数具有更好的数学性质，如，连续可微，用其替代0/1损失函数作为优化目标。

**2️⃣求权重αt更新公式**

第一个基分类器$h_1$是通过直接将及学习算法用于初始数据分布而得；此后迭代地生成$h_t$和$\alpha_t$，当基分类器$h_t$基于分布$D_t$产生后，该基分类器的权重应使得$\alpha_t h_t$最小化指数损失函数

![3766A3F1-2A35-4500-9169-E9736C6168E2](https://i.loli.net/2019/03/23/5c95eee908c9f.png)

其中$\epsilon_t = P_{x \sim D_t} (h_t(x) \neq f(x))$.考虑指数损失函数的导数

![802F5B3B-6F06-45BD-A15D-048BAEA78DC](https://i.loli.net/2019/03/23/5c95eee1938a7.png)

令式(8.10)为零可解得

![C543A744-EC32-4636-9201-265FE430](https://i.loli.net/2019/03/23/5c95eee195361.png)

上式即为图8.3中算法第6行的分类器权重更新公式。

**3️⃣调整样本分布$D_t$**

获得$H_{t-1}$之后样本分布将进行调整，使下一轮的基学习器$h_t$能纠正$H_{t-1}$的一些错误。理想的$h_t$能纠正$H_{t-1}$的全部错误，即最小化

![42446F37-44BF-4C15-872E-64F3A542400B](https://i.loli.net/2019/03/23/5c95eed83f275.png)

注意到$f^2(x) = h_l^2(x) = 1$，式(8.12)可使用的泰勒展式近似为

![A3F3DB0C-BFBF-4AE0-8420-930EA6FC67B7](https://i.loli.net/2019/03/23/5c95eee8ed291.png)

于是，理想的基学习器

![8A3A3FCB-EDC3-4520-9843-DA970124](https://i.loli.net/2019/03/23/5c95eeef92880.png)

注意到$\mathbb{E}_{x \sim D} [e^{-f(x) H_{t-1}(x)}]$是一个常数。令$D_t$表示一个分布

![1A3B6EDB-0BAA-4917-939B-F80093DD336B](https://i.loli.net/2019/03/23/5c95eee196fbc.png)

则根据数学期望的定义，这等价于令

![BDAC1015-DA69-4890-B16D-A93B8387CB99](https://i.loli.net/2019/03/23/5c95eed85966c.png)

由$f(x), h(x) \in \{-1,+1\}$有

![BB28193C-D6AA-477B-81DC-C1B2DAC771](https://i.loli.net/2019/03/23/5c95eee179453.png)

则理想的基学习器

![07228CB1-A4CF-46DE-93A7-2A8EB58CBE85](https://i.loli.net/2019/03/23/5c95eee1b15fc.png)

由此可见，理想的$h_t$将在分布$D_t$下最小化分类误差。因此，弱分类器将基于分布$D_t$来训练，且针对$$D_t$的分类误差应小于$0.5$。这在一定程度上类似“残差逼近”的思想。考虑到$D_t$和$D_{t+1}$的关系，有

![A2D67995-1F26-4A18-9D44-8631807BDE26](https://i.loli.net/2019/03/23/5c95eeefbf854.png)

以上为图8.3中算法第7行的样本分布更新公式。

**学习特定的数据分布**

Boosting算法要求基学习器能对特定的数据分布进行学习。

**方法：**

* **重赋权法 re-weighting**：在训练过程的每一轮中，根据样本分布为每个训练样本重新赋予一个权重。
* **重采样法 re-sampling**：若基学习算法无法接受赋权，则可在每一轮学习中，根据样本分布对训练集重新进行采样，再用重采样而得的样本集对基学习器进行训练。

**注意：**

* 两种方法一般没有显著差别；
* “重采样法”可获得“**重启动**”机会避免训练过早停止[Kohavi and Wolpert, 1996]。

Boosting算法在训练的每一轮都会检查当前生成的基学习器是否满足基本条件（如，图8.3的第5行，检查当前基分类器是否优于随机猜测模型），一旦不满足，则抛弃当前基学习器，学习过程停止。在这种情况下，初始设置的学习轮数T也许还远未达到，可能导致最终集成中值包含很少的基学习器而集成性能不佳。若采用“重采样法”，在抛弃不满足条件的当前基学习器之后，可根据当前分布重新对训练样本进行采样，再基于新的采样结果重新训练处基学习器，使学习过程可以持续到预设的T轮完成。

**[偏差-方差分解](https://octemull.github.io/personal-site/post/ml-chap02/)**

Boosting主要关注降低偏差，因此可以基于泛化性能相当弱的学习器构建出很强的集成。

**举一个例子🌰：**

以决策树桩（单层决策树）为基学习器，在表4.5的西瓜数据集3.0α上运行AdaBoost算法，不同规模size（集成中包含的个体学习器的数目）的集成及其学习器所对应的分类边界如图8.4所示。

![505CDE5C-5C6A-49BC-8819-751435EFF0F8](https://i.loli.net/2019/03/23/5c95eef7a87fd.png)


## 8.3 Bagging与随机森林

现实中无法做到“独立”，但可以使基学习器尽可能具有较大差异。

给定一个训练数据集，一种可能的做法是对训练样本进行采样，产生出若干个不同的子集，再用每个子集训练出一个基学习器。由于数据不同，产生的基学习器可能具有较大差异。

为了获得较好的集成效果，还希望个体学习器不能太差。如果采样出的每个自己都完全不同，则每个基学习器只用到了一小部分训练数据，甚至不足以进行有效学习，这显然无法确保产生较好的基学习器。

为解决该问题，可以考虑**使用相互有交叠的子集**。


### 8.3.1 Bagging

**由来：** Boostrap AGGregatING

**基础方法**：[自助采样法(bootstrap sampling)](https://octemull.github.io/personal-site/post/ml-chap02/)

**基本流程：**

1. 用自助采样法产生T个含m个训练样本的采样集；
2. 基于每个采样集训练出一个基学习器；
3. 将这些基学习器结合
    * 分类：简单投票法，票数相等随机选择、或考察学习器的置信度；
    * 回归：简单平均法。

**算法描述：**
![95AB4167-1AD4-4887-B425-CB8C306059B6](https://i.loli.net/2019/03/23/5c95eeef8cdfe.png)

2：$D_{bs}$是自助采样产生的样本分布。

**优点：**

* **高效、算法复杂度与直接训练一个基学习器的复杂度同阶**

（假定基学习器的计算复杂度为O(m)，则Bgging的复杂度大致为T(O(m)+O(s))。考虑到采样与投票/平均过程的复杂度O(s)很小，而T通常是一个不太大的常数。）

* **可直接用于多分类、回归任务，不用修改**
（标准AdaBoost算法只适用于二分类任务）

* **剩余样本可对泛化性能进行“[包外估计](https://octemull.github.io/personal-site/post/ml-chap02/)”(out-of-bag estimate)**
（每个基学习器值使用了初始训练集中约63.2%的样本，剩余约36.8%的样本可用作验证集。为此需记录每个基学习器所使用的训练样本。不妨令$D_t$表示$h_t$实际使用的训练样本集，令$H^{oob(x)}$表示对样本$x$的包外预测，即仅考虑哪些未使用$x$训练的基学习器在$x$上的预测，有

![10CF8EA0-7ECA-4B8F-861C-6E30D527B4EE](https://i.loli.net/2019/03/23/5c95eee8b8261.png)

则Bagging的泛化误差的外包估计为

![285FA9E7-66AB-4429-9894-29F8FE3E890A](https://i.loli.net/2019/03/23/5c95eee8a9664.png)

）

**包外样本的其他用途——例子🌰：**

* 当基学习器是决策树时，可使用包外样本来辅助剪枝，或用于估计决策树中各节点的后验概率以辅助对零训练样本节点的处理；
* 当基学习器是神经网络时，可使用包外样本来辅助早期停止以减小过拟合风险。

**偏差-方差分解：**

Bagging主要关注降低方差。因此，它在不剪枝决策树、神经网络等易受样本扰动的学习器上效用更为明显。

**举一个例子🌰：**

以基于信息增益划分的决策树为基学习器，在表4.5的西瓜数据集3.0α上运行Bagging算法，不同规模的集成及其基学习器所对应的分类边界如图8.6所示。

![58733FC3-9DF5-414E-BDA7-4BD26C09D832](https://i.loli.net/2019/03/23/5c95eeefbad44.png)

### 8.3.2 随机森林 Random Forest, RF

**与Bagging的关系：**

是Bagging的一个扩展变体。RF在以决策树为基学习器构建Bagging集成的基础上，进一步在决策树训练过程中引入了随机属性选择。

**RF随机选择的操作：**

* 传统决策树在选择划分属性时，是在当前节点的属性集合（假设有$d$个属性）中选择一个最优属性；
* RF对基决策树的每个节点，先从该节点的属性集合中随机选择一个包含$k$个属性的子集，再从该子集中选择最优划分属性。

**k——随机性的引入程度：**

* 若令$k=d$，则基决策树的构建与传统决策树相同；
* 若令$k=1$，则基决策树随机选择一个属性用于划分；
* 一般，推荐值为$k=\log_2 d$ [Breiman, 2001a]。

**优点：**

* 简单、易实现、计算开销小；
* 在很多任务中展现出强大的性能，被誉为“代表集成学习技术水平的方法”。

**与Bagging的差别：**

* **多样性：**
    * Bagging中基学习器的“多样性”仅通过**样本扰动**得到；
    * RF中的基学习器的“多样性”不仅来自于**样本扰动**，还来自于**属性扰动**。因此，RF最终集成的泛化性能可通过个体学习去之间的差异度的增加而进一步提升。
*** 训练效率：**RF > Bagging（通常）
    * Bagging使用“**确定型**”决策树，在选择划分属性时要考虑结点的全部属性；
    * RF使用“**随机型**”决策树，只需考察一个属性子集。

**RF的收敛性：**

与Bagging相似。如图8.7所示，RF的起始性能往往较差（引入属性扰动，往往使RF中个体学习器的性能有所下降），尤其当集成中只包含一个基学习器时。然而，随着个体学习器数目的增加，RF常会收敛到更低的泛化误差。

![0AC3129A-E2E2-4168-81D9-898C0421DA81](https://i.loli.net/2019/03/23/5c95eeefd8c35.png)

## 8.4 结合策略

**结合策略的好处：**

1. **统计的原因**：由于学习任务的**假设空间往往很大，可能有多个假设在训练集上达到同等性能**，此时若使用单学习器可能因误选而导致泛化性能不佳，结合多个学习器会减小这一风险。
2. **计算的原因**：学习算法往往会陷入局部极小，而有的局部极小点对应的泛化性能可能很糟糕，而通过多次运行之后进行结合，**可降低陷入糟糕局部极小点的风险**。
3. **表示的原因**：某些学习任务的**真实假设可能不在当前学习算法考虑的假设空间当中**，此时若使用单学习器则肯定无效，而结合多个学习器，由于相应的假设空间有所扩大，有可能学得更好的近似。

![20801572-84CF-412A-827D-C5B473FD6855](https://i.loli.net/2019/03/23/5c95eeefbd3f2.png)

**符号：**

假定集成包含$T$个基学习器$\{h_1, h_2, \cdots, h_T\}$，其中$h_i$在示例$x$上的输出为$h_i (x)$。以下介绍对$h_i$进行结合的常见策略。

### 8.4.1 平均法 averaging

**输出：**数值型$h_i(x) \in \mathbb{R}$，最常见策略

**1️⃣简单平均法 simple averaging**

![C1AD4D91-5BCC-4371-A6ED-963C0FE60183](https://i.loli.net/2019/03/23/5c95eed32bd1a.png)

**2️⃣加权平均法 weighted averaging**

![-w611](https://i.loli.net/2019/03/23/5c95eed32da43.jpg)
其中$w_i$是个体学习器$h_i$的权重，通常要求$w_i \geq 0, \sum_{i=1}^T w_i = 1$.


> Breiman[1996b]在研究Stacking回归时发现，必须使用非负权重才能确保集成性能由于单一最佳个体学习器，因此在集成学习中一般对学习器的权重施以非负约束。
> 

**注意：**

* 简单平均法是加权平均法令的特例。
* 集成学习中各种结合方法都可看做加权平均法的特例或变体。不同的集成学习方法可视为通过不同的方式来确定加权平均法中的基学习器的权重。
* 习得的权重不一定可靠，若权重过多则易造成过拟合。

加权平均法的权重一般从训练数据中学习而得，现实任务中的训练样本通常不充分或存在噪声，这使学出的权重不完全可靠。特别是对规模较大的集成而言，要学习的权重过多，容易造成过拟合。

> 例如估计出个体学习器的误差，然后令权重大小与误差大小成反比。

* 实验和应用均显示，**加权平均法未必一定优于简单平均法**。
* 一般而言，在个体学习器**性能相差较大时宜使用加权平均**法，而在个体学习器**性能相近时宜使用简单平均法**。

### 8.4.2 投票法 voting

**任务类型：**分类

**符号：**

* $h_i$：学习器；
* $\{c_1, c_2, \cdots, c_N\}$：类别标记集合；
* $(h_i^1(\boldsymbol{x});h_i^2(\boldsymbol{x});\cdots;h_i^N(\boldsymbol{x}))$：$N$维向量，表示$h_i$在样本$\boldsymbol{x}$上的预测输出，其中$h_i^j(\boldsymbol{x})$是$h_i$在类别标记$c_j$上的输出。

对分类任务来说，学习器$h_i$将从类别标记集合$\{c_1, c_2, \cdots, c_N\}$中预测出一个标记。

**1️⃣绝对多数投票法 majority voting**

![42A540C2-158C-4610-BE08-95D9F73D8BB8](https://i.loli.net/2019/03/23/5c95eed848ad8.png)

**判断标准：**

* 若某标记得票过半数，则预测为该标记；
* 否则**拒绝预测**。

**2️⃣相对多数投票法 plurality voting**

![B4ABC5D9-65E8-4D0C-A7BE-A3A4E3ACEAF5](https://i.loli.net/2019/03/23/5c95eed32f4a1.png)

**判断标准：**

* 预测为得票最多的标记（二分类问题下与绝对多数投票法相同）；
* 若同时有多个标记获得最高票，则从中随机选取一个、

**3️⃣加权投票法 weighted voting**

![7201AEF7-FBC6-47CF-9300-4A17DA5B7928](https://i.loli.net/2019/03/23/5c95eed331088.png)

**判断标准：**

* 类似加权平均法，$w_i$是$h_i$的权重，通常$w_i \geq 0, \sum_{i=1}^T w_i = 1$

**说明：**

* 绝对多数投票法的“拒绝预测”选项在可靠性要求较高的学习任务中是一个很好的机制。但若学习任务要求必须提供预测结果，则绝对多数投票 法将退化为相对多数投票法。因此，在不允许拒绝预测的任务中，前两种方法统称为“多数投票法”。

> “多数投票法”的英文术语使用不太一致：有文献称为majority voting，也有直接称为voting。

**输出值类型：**

* 类标记：$h_i^j (\boldsymbol{x}) \in  \{0,1\}$，若$h_i$将样本$\boldsymbol{x}$预测为类别$c_i$则取值为$1$，否则为$0$. 使用类别标记的投票亦称“硬投票”(hard voting)。
* 类概率：$h_i^j (\boldsymbol{x}) \in  [0,1]$，相当于对后验概率$P(c_j|\boldsymbol{x})$的一个估计。使用类概率的投票亦称“软投票”(soft voting)。

**注意：**

* **不同类型的** $h_i^j (\boldsymbol{x})$ **值不能混用**。对一些能在预测出类别标记的同时产生分类置信度的学习器，其分类置信度可转化为类概率使用。

> 若此类值未进行规范化，例如SVM的分类间隔值，则必须使用一些技术如Platt缩放(Platt scalinf)[Platt, 2000]、等分回归(isotonic regression)[Zadrozny and Elkan, 2001]等进行“校准”(calibration)后才能作为类概率使用。

* **若基学习器的类型不同**（如，异质集成中不同类型的个体学习器），**则其类概率值不能直接进行比较**；此时，通常可将类概率输出转化为类标记输出（例如，将类概率输出最大的$h_i^j (\boldsymbol{x})$设为1，其他设为0）然后再投票。
* 虽然分类器估计出的类概率值一般都不太准确，但**基于类概率进行结合却往往比直接基于类别标记进行结合性能更好**。

### 8.4.3 学习法

**学习法：** 当训练数据很多时，通过另一个学习器来进行结合的结合策略。

**典型代表：** Stacking [Wolpert, 1992; Breiman, 1996b]

> Stacking本身是一种著名的集成学习方法，且有不少集成学习算法可视为其变体或特例。它也可看做一种特殊的结合策略。

**定义：**

* 初级学习器：个体学习器；
* 次级学习器 / 元学习器(meta-learner)：用于结合的学习器。

**基本思路：**

1. 从初始数据集训练出初级学习器；
2. 将初级学习器的输出当做样例输入特征、初始样本标记仍当做样例标记，生成新数据集；
3. 用新数据集训练次级学习器。

**算法描述：**

假设初级集成是异质的（也可同质）。

![F652F675-9C33-4E3F-81C1-56CE33EF208A](https://i.loli.net/2019/03/23/5c95eeefc94d3.png)

1：使用初级学习算法𝔏𝑡产生初级学习器ℎ𝑡。
4：生成次级训练集。
11：在$D'$上用次级学习算法𝔏产生次级学习器ℎ'。

**说明：**

若直接用初级学习器的训练集来产生次级训练集，则过拟合风险会较大；因此，一般通过**CV**或**LOO**的方式，用训练初级学习器**未使用的样本**来产生次级学习器的训练样本。

**举一个例子🌰：**

以$k$折交叉验证为例，初始训练集$D$被随机划分为$k$个大小相似的集合$\{D_1, D_2, \cdots, D_k\}$。令$D_j$和$\bar{D}_j=D\backslash D_j$分别表示第$j$折的测试集和训练集。给定$T$个初级学习算法，初级学习器$h_t^{(j)}$通过在$\bar{D}_j$上使用第$t$个学习算法而得。对$D_j$中每个样本$\boldsymbol{x}_i$，令$z_{it} = h_t^{(j)} (\boldsymbol{x}_i)$，则由$\boldsymbol{x}_i$所产生的次级训练样例的示例部分为$z_i=(z_{i1}; z_{i2}; \cdots;  z_{iT})$，标记部分为$y_i$。于是，在整个CV过程结束后，从这$T$个初级学习器产生的次级训练集是$D'=\{(z_i, y_i)\}_{i=1}^m$，然后后$D'$将用于训练次级学习器。

**其他方法：**

**MLR：**

- **次级学习器的输入属性表示和次级学习算法对Stacking集成的泛化性能有很大影响**
- 有研究表明，将初级学习器的输出类概率作为次级学习器的输入属性，用多响应线性回归(Multi-response Linear Regression, MLR)作为次级学习算法效果较好[Ting and Witten, 1999]，在MLR中使用不同的属性集更佳[Seewald, 2002]。

> MLR是基于线性回归的分类器，它对每个类分别进行线性回归，属于该类的训练样例所对应的输出被置为1，其他类置为0；测试示例将别分给输出值最大的类。
> WEKA中的StackingC算法就是这样实现的。

**BMA：**

贝叶斯模型平均(Bayes Model Averaging, BMA)基于后验概率来为不同模型赋予权重。与Stacking模型相比[Clarke, 2003]，

* 理论上，若数据生成模型恰在当前考虑考虑的模型中，且数据噪声很少，则BMA不差于Stacking；
* 然而，现实中前一条件无法保证，甚至难以用当前考虑的模型来近似，因此Stacking通常由于BMA。因为Stacking的鲁棒性比BMA更好，且BMA对模型近似误差非常敏感。


## 8.5 多样性

### 8.5.1 误差-分歧分解

**“好而不同”的理论分析**

假定我们用个体学习器$h_1,h_2, \cdots, h_T$通过加权平均法(8.23)结合产生的集成来完成回归学习任务$f: \mathbb{R}^d \mapsto \mathbb{R}$. 对示例$\boldsymbol{x}$，定义学习器$h_i$的“分歧”（ambiguity）为

![D2B1FBAC-E5B2-4E2E-B916-FCB00C211D7B](https://i.loli.net/2019/03/23/5c95eee8cae76.png)

则集成的“分歧”为

![CEE47D28-8359-4C99-9BC3-F95D3EBD4368](https://i.loli.net/2019/03/23/5c95eee8ce547.png)

**分歧：**

**表征了个体学习器在样本𝒙上的不一致性，即在一定程度上反映了个体学习器的多样性。**

个体学习器ℎ𝑖和集成𝐻的平方误差分别为

![65BE2696-68F5-41C1-85E5-F3B0C64803A1](https://i.loli.net/2019/03/23/5c95eee8ccb22.png)

令$\bar{E}(h | \boldsymbol{x}) = \sum_{i=1}^T w_i \cdot E(h_i |\boldsymbol{x})$表示个体学习器误差的加权均值，有

![C7AA0A95-761F-4B3D-B8F7-738148FFCB20](https://i.loli.net/2019/03/23/5c95eee8d00e8.png)

式(8.31)对所有样本$\boldsymbol{x}$均成立，令𝑝(𝒙)表示样本的概率密度，则在全样本上有

![4C258AA4-DD28-4A03-9ED7-505DB41B4138](https://i.loli.net/2019/03/23/5c95eed861e5e.png)

类似的，个体学习器ℎ𝑖在全样本上的泛化误差和分歧项分别为

![70B8833D-30B0-4AA5-B497-3B73D72D30A5](https://i.loli.net/2019/03/23/5c95eed843a5f.png)

集成的泛化误差为

![79EEA070-3E12-4A17-A626-2BF973DA7202](https://i.loli.net/2019/03/23/5c95eee1a36c6.png)


将式(8.33)~(8.35)代入式(8.32)，再令$\bar{E} = \sum_{i=1}^T w_i E_i$表示个体学习器泛化误差的加权均值，$\bar{A} = \sum_{i=1}^T w_i A_i$表示个体学习器的加权分歧值，有

![8BF5BCCF-9B35-4175-9135-3977CFC18011](https://i.loli.net/2019/03/23/5c95eed31cbaa.png)


以上即**“误差-分歧分解”(error-ambiguity decomposition) **[Krogh and Vedelsby, 1995]，表明：

* 个体学习器准确性越高、多样性越大，则集成越好。

**问题：**

现实任务中很难直接优化$\bar{E} - \bar{A}$

* 它们定义在整个样本空间上；
* $\bar{A}$不是一个可直接操作的多样性度量，只能在集成构造好后估计。

> 以上推导只适用于回归问题，难以直接推广到分类学习任务中。

### 8.5.2 多样性度量 / 差异性度量

**多样性度量：**

度量集成中个体分类器的多样性，即估算个体学习器的多样化程度。典型做法是考虑个体分类器的两两相似/不相似性。

给定数据集$D=\{(\boldsymbol{x}_1, y_1), (\boldsymbol{x}_2, y_2), \cdots, (\boldsymbol{x}_m, y_m)\}$，对二分类任务$y \in \{-1, +1\}$，分类器$h_i$与$h_j$的预测结果列联表(contigency  table)为

![7AFDD865-0F8A-4592-8823-D5ED84684](https://i.loli.net/2019/03/23/5c95eed84a782.png)

其中，$a$表示$h_i$与$h_j$均预测为正类的样本数目；$b$、$c$、$d$含义由此类推；$a+b+c+d=m$。基于列联表，给出常见的多样性度量如下：

* **不合度量 disagreement measure**
![55039E0C-CE15-4292-A324-B31E154B0261](https://i.loli.net/2019/03/23/5c95eee1a1a9c.png)
$𝑑𝑖𝑠_{𝑖𝑗}$的值域为$[0, 1]$。值越大表示多样性越大。

* **相关系数 correlation coefficient**

![2F4271E4-9F9B-4DAC-9568-F7B4F24BA463](https://i.loli.net/2019/03/23/5c95eed847103.png)

$\rho_{ij}$的值域为$[-1, 1]$。若$h_i$与$h_j$无关，则值为$0$；若正相关，则为正，否则为负。

* **Q-统计量 Q-statistic**

![236D4543-903E-4D84-A7CF-6019C55AE66D](https://i.loli.net/2019/03/23/5c95eed841f95.png)

$Q_{ij}$与相关系数的符号相同，且$|𝑄_{𝑖𝑗}|≥|𝜌_{𝑖𝑗}|$。

* **𝜅-统计量 k-statistic**

![8E99D504-6CCC-4199-82BB-7374C197FB2B](https://i.loli.net/2019/03/23/5c95eee1a4e96.png)

$p_1$是两个分类器取得一致的概率；$p_2$是两个分类器偶然达成一致的概率。可由数据集D估算：

![BC1E0F4A-4726-4823-AECD-F63A1BB64792](https://i.loli.net/2019/03/23/5c95eed84552b.png)

若$h_i$与$h_j$在$D$上完全一致，则$k=1$；若$h_i$与$h_j$仅是偶然一致，则$k=0$。$k$通常非负，仅在达成一致的概率甚至低于偶然性的情况下取负值。

以上均为“成对型”pairwise多样性度量，可在二维图中绘制出来。

**举一个例子：**

“k-误差图”就是将每一对分类器作为图上的一个点，横坐标是这对分类器的k值，纵坐标是它们的平均误差，图8.10给出了两个例子。显然，数据点云的位置越高，则个体分类器准确性越低；点云位置越靠右，则个体学习多样性越小。

![87C8EA00-8992-45FF-A93B-560C3AB876F3](https://i.loli.net/2019/03/23/5c95eef7a0f2b.png)


### 8.5.3 多样性增强

**一般思路**：在学习过程中引入随机性

**常见做法：**

####  1️⃣ 数据样本扰动（简单高效、使用最广）

**基本思路：**

给定初始数据集，从中产生不同的子集，再利用不同的数据子集训练出不同的个体学习器。通常基于采样法。

**例子：**

Bagging中的自助采样，AdaBoost中使用的序列采样。

**适用情况：**

* 对决策树、神经网络等有显著改变，此类学习器是“不稳定基学习器”；
* 线性学习器、SVM、NB、k近邻学习器对样本扰动不敏感，它们称作“稳定基学习器”(stable base learner)，不适用样本扰动。

#### 2️⃣ 输入属性扰动

**基本思路：**

从不同的“子空间”（subspace，属性子集）训练个体学习器。

**代表方法：**随机子空间算法 (random subspace)

从初始属性集中抽取出若干个属性子集，再基于每个属性子集训练一个基学习器。

![170E07D9-1456-4C1C-B8AF-5CA75A945637](https://i.loli.net/2019/03/23/5c95eeefc38c0.png)

𝑑'小于初始属性数𝑑。
2：𝓕𝑡包含𝑑'个随机选取的属性，𝐷𝑡仅保留𝓕𝑡中的属性。

**适用情况：**

* 适用于包含大量属性的数据集，不仅能产生多样性大的个体学习器，还能因属性数目的减少而大幅降低时间开销。（由于属性多，减少属性后生成的学习器也不会太差）
* 不适用于只包含少量属性、或冗余属性很少的数据。

#### 3️⃣ 输出表示扰动

**基本思路：**

对输出表示进行操纵以增强多样性。

**方法：**

* **翻转法 Flipping Output** [Breiman, 2000]：随机改变部分训练样本的标记；
* **输出调制法 Output Smearing** [Breiman, 2000]：对输出表示进行转化，将分类输出转化为回归输出后构建个体学习器；
* **[ECOC法 [Dietterich and Bakiri, 1995]](https://octemull.github.io/personal-site/post/ml-chap03/)**：利用纠错输出码将多分类任务拆解为一系列二分类任务来训练基学习器。

#### 4️⃣ 算法参数扰动

**基本思路：**

随机设置不同的算法参数。

**方法：**

* **负相关法 (Negative Correlation) **[Liu and Yao, 1999]：显式地通过正则化项来强制个体神经网络使用不同的参数。（如，神经网络的隐层神经元数、初始连接权值等）
* 对参数较少的算法，可**将其学习过程中某些环节用其他类似方式代替**。如，将决策树使用的属性学安装机制替换成其他属性选择机制。

**注意：**

* 使用单一学习器时，通常需使用CV来确定参数值，实际训练出了有不同参数的学习器，但最后只选择了其中一个。集成学习相当于利用了所有学习器。
* 由此可见，集成学习的实际计算开销并不比使用单一学习器大很多。

> **不同的扰动机制可单独使用、亦可同时使用**。如8.3.2中的RF同时使用了数据样本扰动和输入属性扰动，有的方法甚至同时使用了更多机制。
